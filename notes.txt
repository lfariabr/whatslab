18/09
- api
- core
- instance
- leadgen
- users
- frontend

19/09
- componente apicrmgraphql
- leadgen > subidor de leads
- frontend > upload.html, view_leads.html

20/09
- home/core
- home/botox
- componente apisocialhub + graphQL
- requirements.txt
- send message - test.py
- send message - test graphiQL

21/09
- datawrestler_part1: GET from core, leadLP + LeadWPP to process
- datawrestler_part2: groupby sent_message
- datawrestler_part2: GET from api socialhub response of sent message
Blueprint & routes datawrestler
GraphQL datawrestler 
datawrestler_part3: GET from crm graphql appointments
datawrestler_part3: GET from crm graphql view_leads

22/09
- datawrestler_part3 resolvers.py: include date filter
- datawrestler_part4: resolvers.py resolve leads with same date filter
- datawrestler_part5: cross with whatsapp lead to see if they're appointment or leads
- datawrestler_part6: cross it all df_receive_messages and send_message logs
- datawrestler_part7: app_context e 
- blueprint run-datawrestlergit fetch origin
- datawrestler_part8: apscheduler in app context

23/09
- organizar .env
- organizar requirements.txt
- push github
- vercel deploy & connect
- escrever tudo o que tem no banco

24/09
- Entender melhor o datarwrestler running scheduler
- Mapear o erro de certificado
- Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED

25/09
- preparar para papo com Samir

27/09
- resolver certificado disparo

28/09 
- CRUD msgs componente de cadastro de mensagens (txt/foto)
- header dinamico frontend core
- ajuste das rotas para crud msgs
- deploy github
- componente cadastrar telefones no frontend
- deploy github

29/09
- organizar disparo das mensagens de acordo com as regras + tokens
- criar def get_message e printar query
- fazer def get_message retornar um dicionário
- encaixar a mensagem dentro do data_wrestling
- enviar token phone number a partir do UserPhone
- encaixar o token do phone number dentro do data_wrestling
- encaixar o token e a Mensagem no Log de envios
- review today's updates

30/09
- review updates made on 29/09
- readme file
- deploy updates
- test "live" environment
- incluir no histórico o número do phone_sender
- api permitir alterar/excluir leads

01/10
- Ajuste no log, passando corretamente:
- ID: 5, LeadPhone: 11963546222, Message ID: botoxd1, 
- Status: sent, Sender PhoneNb: 11988446710, 
- Date Sent: 2024-10-01 16:28:56.213837
- conferir o  Message Log counter do datawrestler pois nao está me contando... 

02/10 papo Samir
- está seguro enviar o token desta forma? na requisicao - SIM
- vê problema em rodar a query diariamente? 30 pra frente e 30 pra trás - NAO, SEGUIR
- próximos passos rodar online, sem ser local? montamos checklist

03/10 
- implementar send_message_with_file e cherry pick_message
- cherry pick deploy
- subir arquivos no messageForms <config UPLOAD_FOLDER> (user>messages>uploads)
- salvando arquivos no servidor e ajustando o nome do arquivos
- rota para servir arquivos da pasta de upload
- exibimos no frontend o nome do arquivo e permitimos o download

04/10
- testar send_message_with_file e send_message without file cases
- test send message without file and worked with changes resolvers.apisocialhub
- delete_message_logs.py

05/10
- resolver o content-Type: multipart/form-data 
- testar send_message_with_file e send_message without file cases
- preparar estrutura final Samir

06/10
- commit changes
- prepare research to use base
- https://www.postgresql.org/download/

07/10
- pensar em como estrutura SUPABASE / POSTGRESQL
- fomos de PostgreSQL
- flask db stamp head -> synch migrations
- rever estrutura supabase anterior

08/10
- resolver upload de arquivos / mensagens
- ter as opcoes supabase / sqlite > flask db stamp head
- fazer mais um teste configurando msg + msg + video e msg +foto 
- interfce para visualizar o banco de dados 
- conseguir intercalar entre supabase/sqlite
- aprender a mexer no supabase
- multiplos senders: botox/preenchimento
- deploy

09/10
- migrar CSV para o banco (leads / sent_messages)
- create resolvers2 optimzing multiple tokens & campaigns
- resolvers2 to deal with "dias_depois_da_conversa" + contador
- import time and rest 10s between messages
- adicionar um rest 10-15s cada mensagem
- validar implementacao/lentidao do banco

10/10
- criei dicionário de regiao em dicts.py
- adicionei a funcao create_leads no apicrmgraphql>leads_resolver
- preparei o terreno no datawrestler
- atualizar classe leadwhatsapp para refletir as colunas novas (store, region, tags)
- atualizar form LeadWhatsappLandingPage com as 3 colunas novas
- atualizar html view_leads com 3 novas colunas
- atualizar html edit_leads com 3 colunas novas
- atualizar edit no routes.py leadgenlp com 3 colunas novas
- inserir no datacleaner funcoes create_store e create_region
- resolvers2 rule to upload leads GraphQL
- inserir no dics.py os DDDs
- chamar estas funcoes na hora de adicionar CSV
- chamar as funcoes para upload do lead na rota
- inserir upload leads no datawrestler
- brute force test contador = 4 upload lead - WORKING MOTHERFUCKER!!!
- create function print_all_messages on delete_messages_log.py

11/10
- testar o disparo botox 1,2,3,4 continue didn't work
- testar o disparo botox 1,2,3,4 message_key = None worked and is logging
- migrar banco para supabase
- commit changes
- vercel solve env variable for supabase
- deal with slow database timeout: FIXED db.create_all() on main.py
- created SSH file to encrypt and authenticate connection between computer and SSLCertVerificationError
- ssh replaces the need for password
- create a droplet in digital ocean 
- create a password
- connect to droplet : ssh root@<157.245.216.158> 
(env) luisfaria@Luiss-MBP _flaskv3 % ssh root@157.245.216.158  
- add root@1... to list of known hosts
- config do servidor Ubuntu no droplet
    - sudo apt update && sudo apt upgrade -y
    - instalamos o docker
    - clonamos o repo github
- criamos uma imagem do app em docker
    - criamos docker-compose-yml
    - docker build -t flask-app .
    - docker run -d -p 5000:5000 flask-app
- instalamos nginx
    - sudo apt install nginx
- configuramos nginx para redirecionar requests do dominio para a app flask
    sudo ln -s /etc/nginx/sites-available/konquista.com.br /etc/nginx/sites-enabled/
    sudo systemctl restart nginx
- configuramos o DNS no registro br
    - apontamos para o endereo do droplet (157...)

12/10
- criacao e config ssh - protocolo secure shell / devops, backend
- config droplet usando Ubuntu (Linux) para hospedar app flask / cloud, devops, infra
- firewall e seguranca de rede (ufw). 5000 flask e 80 nginx / security
- install and docker container config / devops, soft engineer, infra
- deply in docker port 5000 with nginx reverse proxy and load balancer to manage http / backend, devops, soft engineer
- nginx reverse proxy: http > flask + http -> https / devops, infra, security
- dns config and propag / dns, infra
- ssl implementation / dns, infra, infosec
- study what we did and learnt with devops/docker/infra

13/10
- http://127.0.0.1:5000/core/datawrestler
- printar logs do run_datawrestler no frontend
- http://127.0.0.1:5000/core/message_logs
- exibir histórico de mensagens enviadas no frontend
@ sudo nano /etc/nginx/sites-available/default
limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;
- implement Rate Limiting by IP to avoid ddos
- block malicious requests within nginx
# Cabeçalhos de segurança
add_header X-Frame-Options "SAMEORIGIN";
add_header X-XSS-Protection "1; mode=block";
add_header X-Content-Type-Options "nosniff";
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
- sudo apt install fail2ban
- logs do nginx:  tail -f /var/log/nginx/access.log /var/log/nginx/error.log
- certbot (already implemneted 12/10)
- UFW firewall (already implemented 12/10)
sudo apt update && sudo apt upgrade

14/10:
- deixar bonito... datawrestler e message logs
- inserir disparador e message logs no painel de mensagens
- dark background core component
- changing message type to db.text instead of db.String(256)
- accepting "enter" character on texts 
- update all text messages
- Commit changes
- Test vercel
- Image Docker
a conectar no droplet > git pull origin main
b reconstruir a imagem no docker> sudo docker build -t whatslab-image .
c parar container atual: sudo docker stop e63cf189dc59
d remover container atual: sudo docker rm e63cf189dc59
c rodar um novo container baseado na nova imagem
sudo docker run -d -p 5000:5000 --name whatslab-container whatslab-image

15/10
- adding images on the frontend
- testar disparo de pesquisa d7
- SELECT setval(pg_get_serial_sequence('messagelist', 'id'), COALESCE(MAX(id), 1) + 1, false) FROM messagelist;
- update all file on messages 
- adjust database column to 1000 characters
ALTER TABLE message_logs
ALTER COLUMN message_text TYPE VARCHAR(1000); -- Adjust the size as per your requirements
- testar rodar botox full cycle (validate msgs+texts)
- testar rodar preenchimento full cycle (validate msgs+texts)
- Inserir log de lead upload
- did the same on SQLAlchemy
flask db migrate -m "Increase message_text length to 1000"
flask db upgrade
- commit changes
- push to production
ssh root@157.245.216.158
cd flask_app
git pull origin main
sudo docker build -t whatslab-image .
# Remove existing container
sudo docker stop whatslab-container
sudo docker rm whatslab-container
# Start a new container
sudo docker run -d -p 5000:5000 --name whatslab-container whatslab-image
# Check container
sudo docker ps

________________________
python wsgi.py
BACKLOG
________________________

to be done
- testar rodar um período maior query leads e agd (15 dias)
- preparar o primeiro disparo: leads, historico.. já dar o start por aqui!
- pensar em um limitador nos contatos (em data?)
- importar o histórico de mensagens enviadas e contatos
- fazer primeiro disparo 100% do script botox/preenchimento
    
comming next
- exibir historico de mensagens enviadas no lead
- resolvers 2.0 para incluir ativo de falta
- protect api access
- incluir stripe
- POST to crmgraphql follow_up comments (pos-vendas)


___ Anotacoes Samir infra
- http://127.0.0.1:5000 (5000 = porta firewall - para coordenar entrada/saída)
    80http e 443https - frontend do site (procorpo.com.br)
    apache / nginx (webserver) 
- administra origem da sessão do user
- faz limpeza da URL (evitar injection, parâmetros)
- requirements dentro do ambiente
- frontend + python (não precisa de infra separada: monolito)
- recebimento de arquivos? (n/a pois nao temos upload)
- limit de upload (definir)
- certificado (lets encrypt) para rodar https
http -> texto da req direto (listener requisicoes no roteador)
https -> junto da resposta do site, versão publica do certificado (no navegador)
os dados sao criptografados com chave publica (chave privada no servidor transforma)

api: php laravel api geral
fila: php artisan qeue work